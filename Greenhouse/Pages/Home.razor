@using Common
@using Common.Components
@using Common.Components.Base

@page "/"

@* <APlane	Color="red"		Opacity=0.0	P="new Position(1,0,0)"		R="new Rotation(-90,0,0)"	WH="new WidthHeight(20,24)"	/> <!-- invfloor -->
<APlane	Color="green"	Opacity=0.0 P="new Position(11,3,0)"	R="new Rotation(0,90,0)"	WH="new WidthHeight(24,6)"	/> <!-- invwallwest -->
<APlane	Color="blue"	Opacity=0.0 P="new Position(1,3,12)"	R="new Rotation(0,0,0)"		WH="new WidthHeight(20,6)"	/> <!-- invwallnorth -->
<APlane	Color="yellow"	Opacity=0.0 P="new Position(1,3,-12)"	R="new Rotation(0,0,0)"		WH="new WidthHeight(20,6)"	/> <!-- invwallsouth -->
<APlane	Color="pink"	Opacity=0.0 P="new Position(-9,3,0)"	R="new Rotation(0,90,0)"	WH="new WidthHeight(24,6)"	/> <!-- invwalleast --> *@
<AModel Topic="earth" GLTFHref="#earth" OnModelLoadedCallback="@ec" CollisionType="CollisionType.ConvexRecursive"></AModel>
<AImage ImagePath="#signimage" P="@(new Position(9.09,1.1,6.21))" R="@(new Rotation(-10,219,5))" WH="@(new WidthHeight(1.2,0.5))"></AImage>

@foreach (ComponentBase e in entities.Values)
{
	<DynamicComponent Type="@e.GetType()" Parameters="ComponentParameters.Get(e)" />
}

@code
{
	private Dictionary<string, ComponentBase> entities = new();
	private Queue<(string, ComponentBase)> entityLoadQueue = new();
	private EventCallback<string> ec;

	protected override async Task OnInitializedAsync()
	{
		Console.WriteLine("OnInitializedAsync");
		
		ec = EventCallback.Factory.Create<string>(this, OnModelLoadedCallback);

		await base.OnInitializedAsync();
	}

	protected override async Task OnParametersSetAsync()
	{
		Console.WriteLine("OnParametersSetAsync");

		await base.OnParametersSetAsync();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		Console.WriteLine($"OnAfterRenderAsync({firstRender})");

		if(firstRender)
		{
			//entityLoadQueue.Enqueue(("earth",			new AModel("earth",			"#earth",					ec, CollisionType.ConvexRecursive)));
			entityLoadQueue.Enqueue(("ccollideonly",	new AModel("ccollideonly",	"#ccollideonly",	ec, CollisionType.NonconvexRecursive)));
			entityLoadQueue.Enqueue(("cpebbles",		new AModel("cpebbles",		"#cpebbles",		ec))); // maybe no collision
			entityLoadQueue.Enqueue(("cleaves",			new AModel("cleaves",		"Assets/CLeaves.gltf",		ec, CollisionType.None)));
			entityLoadQueue.Enqueue(("door",			new AModel("door",			"Assets/Door.gltf",			ec, CollisionType.None)));
			entityLoadQueue.Enqueue(("cphysical",		new AModel("cphysical",		"Assets/CPhysical.gltf",	ec)));
			entityLoadQueue.Enqueue(("bench",			new AModel("bench",			"Assets/Bench.gltf",		ec)));
			entityLoadQueue.Enqueue(("chair",			new AModel("chair",			"Assets/Chair.gltf",		ec)));
			entityLoadQueue.Enqueue(("containerfloating",new AModel("containerfloating","Assets/ContainerFloating.gltf",ec)));
			entityLoadQueue.Enqueue(("lily00",			new AModel("lily00",		"Assets/Lily00.gltf",		ec)));
			entityLoadQueue.Enqueue(("lily01",			new AModel("lily01",		"Assets/Lily01.gltf",		ec)));
			entityLoadQueue.Enqueue(("sign", new AModel("sign", "Assets/Sign.gltf", ec, CollisionType.ConvexRecursive)));
			
			_ = LoadNextModel();
		}
	}

	private void OnModelLoadedCallback(string topic)
	{
		Console.WriteLine($"Loaded {topic}");

		_ = LoadNextModel();
	}
	
	private async Task LoadNextModel()
	{
		await Task.Run(() =>
		{
			(string topic,ComponentBase component) toDequeue;
			if(entityLoadQueue.TryDequeue(out toDequeue))
			{
				Console.WriteLine($"Adding {toDequeue.topic}");
				entities.Add(toDequeue.topic,toDequeue.component);
				StateHasChanged();
			}
		});
	}
}