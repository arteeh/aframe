@page "/"

@using Common
@using Common.Components

<AModel GLTFHref="Assets/Earth.gltf" CollisionType=CollisionType.ConvexRecursive />

@* <ASky Color="#040020"></ASky> *@
<a-entity environment="preset: starry; ground: none;"></a-entity>

@foreach (ComponentBase e in entities.Values)
{
	<DynamicComponent Type="@e.GetType()" Parameters="@ComponentParameters.Get(e)" />
}

@* <script>
	window.loadDoneCallback = () => {
    	DotNet.invokeMethodAsync('Greenhouse','OnLoadDoneCallback');
	}
</script> *@

@code {

	private Dictionary<string, ComponentBase> entities = new();
	private Queue<(string, ComponentBase)> entityLoadQueue = new();
	protected override async Task OnParametersSetAsync()
	{
		Console.WriteLine("OnParametersSetAsync");
		await base.OnParametersSetAsync();
	}

	protected override async Task OnInitializedAsync()
	{
		Console.WriteLine("OnInitializedAsync");

		entityLoadQueue.Enqueue(("entities/ccollideonly", new AModel("Assets/CCollideOnly.gltf", CollisionType.NonconvexRecursive)));
		entityLoadQueue.Enqueue(("entities/cpebbles", new AModel("Assets/CPebbles.gltf"))); // maybe no collision
		entityLoadQueue.Enqueue(("entities/cleaves", new AModel("Assets/CLeaves.gltf", CollisionType.None)));
		entityLoadQueue.Enqueue(("entities/door", new AModel("Assets/Door.gltf", CollisionType.None)));
		entityLoadQueue.Enqueue(("entities/cphysical", new AModel("Assets/CPhysical.gltf")));
		entityLoadQueue.Enqueue(("entities/bench", new AModel("Assets/Bench.gltf")));
		entityLoadQueue.Enqueue(("entities/chair", new AModel("Assets/Chair.gltf")));
		entityLoadQueue.Enqueue(("entities/containerfloating", new AModel("Assets/ContainerFloating.gltf")));
		entityLoadQueue.Enqueue(("entities/lily00", new AModel("Assets/Lily00.gltf")));
		entityLoadQueue.Enqueue(("entities/lily01", new AModel("Assets/Lily01.gltf")));

		await base.OnInitializedAsync();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		Console.WriteLine($"OnAfterRenderAsync({firstRender})");

		(string topic,ComponentBase component) toDequeue;
		if(entityLoadQueue.TryDequeue(out toDequeue))
		{
			//await Task.Delay(2000); // replace with "wait until done loading previous model"
			entities.Add(toDequeue.topic,toDequeue.component);
			StateHasChanged();
		}
		
		// TODO: little sign with:
		// "Stylized Mangrove Greenhouse by Andrey Bársh"
		// "VR port by arteeh"
	}

	[JSInvokable("OnLoadDoneCallback")]
	public static Task OnLoadDoneCallback()
	{
		Console.WriteLine($"OnLoadDoneCallback");
		return Task.CompletedTask;
	}

}	